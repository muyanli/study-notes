# Lecture 2 - Binary Search & Sorted Array


## Binary Search

经常把最后两个数nums【start】和nums【end】写到while循环里！！！要注意！！

* 457 · Classical Binary Search

* 1536 · Find First and Last Position of Element in Sorted Array

* LC278 First Bad Version

* 75 · Find Peak Element

* LC 74. Search a 2D Matric
* LC 240. Search a 2D Matrix II
  从左下角往右上角扫描，T为 O(m+n)


## Rotated Sorted Array - 重要

*  LC153  [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

*  LC154  Find Minimum in Rotated Sorted Array II   https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/submissions/

     有重复的数字，先把重复数字剔除干净，worst case TC is O(n),因为最差情况需要把所有重复数据都提出一遍，例如 1，1，1，1，1，1，2，1

*  LC33. Search in Rotated Sorted Array
    注意等号情况！！！容易错

*  LC81. Search in Rotated Sorted Array II


## Find Median, Find Kth Element in 2 Sorted Array
* LC4. Median of Two Sorted Arrays
     非常多边界条件

## Reverse String in place
* 39 · Recover Rotated Sorted Array
  先二分找出最小值，然后三步翻转法
  如果有重复数字就没法二分了，只能打擂台找到最小值

* LC 796. Rotate String 暴力解决
* LC 151. Reverse Words in a String
  暴力解决，考察的是对于空格的处理。“    hello world     ”.split(" ") 的结果数组里会有很多空string

  
# Lecture 3 - Binary Tree, Divide and Conquer
  TC trainning
  - 在O（n）的时间把n的问题变成2个n/2的问题？ TC是O(nlogn), merge sort, quick sort   --- 这两个要掌握
  - 在O（1）的时间把n的问题变成2个n/2的问题？ TC是O(n) 二叉树上经常是O(n)
  - 在O（1）的时间把n的问题变成1个n/2的问题？ TC是O(logn) binary search
    
* 用树形分析法分析时间复杂度

* Recursion on Binary Tree
* Traverse and  Divide&Conquer 二者的区别
  - Traverse不用return value， 自顶向下
  - Divide&Conquer有return value， 自底向上

* 二叉搜索树
  中序遍历是不下降序列，O（h）的时间查找，删除，插入
  高度并不是logN！！！！只有balanced BST的高度是logN

Problems
- Binary Tree DFS Traversal: Use Stack - 必背
  
  -  LC144 Binary Tree Preorder Traversal [https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/]
  -  LC94 Binary Tree Inorder Traversal [https://www.jiuzhang.com/solution/binary-tree-inorder-traversal/]
  -  LC145 Binary Tree Postorder Traversal [https://www.jiuzhang.com/solution/binary-tree-postorder-traversal/]

第一类考察形态： 二叉树上求值求路径
* LC 257. Binary Tree Paths
* LC 124. Binary Tree Maximum Path Sum  （需二刷）全局变量记录当前最大值
* LC 236. Lowest Common Ancestor of a Binary Tree
* LC 1644. Lowest Common Ancestor of a Binary Tree II 两个数不保证一定有怎么办？
* LC 1650. Lowest Common Ancestor of a Binary Tree III 如果有parent指针会不会快一些？

第二类考察形态： 二叉树结构变换

第三类考察形态： 二叉树搜索树BST 特别重要，需要二刷
* LC 98. Validate Binary Search Tree
* LC 173. Binary Search Tree Iterator 背诵！！！

挪到下一个点的算法是：
如果当前节点存在右子树，那么就是右子树中最左边的点
如果当前节点不存在右子树，那么就是往上看，走到当前节点的路径中，第一个左拐的点

```java
    getNext() {
        let node = this.stack[this.stack.length-1];
        let resultNode = node;

        if (node.right === null) {
            node = this.stack.pop();
            while( this.stack.length > 0 && this.stack[this.stack.length-1].right === node) {
                node = this.stack.pop();
            }
        } else {
            node = node.right;
            this.stack.push(node);
            while(node.left != null) {
                this.stack.push(node.left);
                node = node.left;
            }
        }

        return resultNode;
    }
```
* LC 230. Kth Smallest Element in a BST
  
  本质也是 BST Iterator，注意BSTIterator Class怎么写  TC = O(h+k)
  follow up: 如果BST经常被修改怎么办？如何优化？
  可以在TreeNode上增加一个counter，在修改的时候更新收到影响节点的counter，或者hashmap<TreeNode, Integer>也行
  时间复杂度是O(h)

* LC 270. Closest Binary Search Tree Value
  
  UpperBound/LowerBound 办法，TC 是 O(logN)
* LC 272. Closest Binary Search Tree Value II
  
  UpperStack/LowerStack, moveUpper, moveLower
  moveUpper 和moveLower TC 都是O（h）,因为是worst case
  时间复杂度 o(h+k), h是最开始构建stack的TC， k是找到k个点
  
* LC 701. Insert into a Binary Search Tree
* LC 450. Delete Node in a BST
  如何实现successor / pressoder
  这两道题是结构改变，
```java
if (val < root.val) {
      root.left = insertIntoBST(root.left, val);
  } else {
      root.right = insertIntoBST(root.right, val);
  }
```

# Lecture 4 BFS & Topological Sorting
- 什么时候使用BFS？
    - 图的遍历: 分层便利，由点及面，拓扑排序
    - 求最短路径
    - 非递归的方式找所有方案
- 二叉树上的BFS
- 图上的BFS
- 矩阵上的BFS
- 拓扑排序

Problems
- 遍历
  * LC 102. Binary Tree Level Order Traversal
  * LC 107. Binary Tree Level Order Traversal II
  * LC 103. Binary Tree Zigzag Level Order Traversal
  * LC 297. Serialize and Deserialize Binary Tree  用isLeft来控制往树上放节点
  * LC 426. Convert Binary Search Tree to Sorted Doubly Linked List 感觉并不是遍历？用DFS divide and conquer

- 图上的BFS - 用HashMap 记录节点
  * LC 261. Graph Valid Tree

    如何判断图是否是树？ edges数量必须是节点数 -1， 且所有节点联通
    edges = node - 1? 如果不是直接return false，如果是的话先build graph，bfs，判断联通的节点数是否是n
    
    时间复杂度分析？
    假设有n个点，m条边。
    用邻接矩阵存储n个点之间的边的关系，空间复杂度为O(n^2)。
    建图时每条边都会访问 1 次，搜索时每个点都会被询问1次，时间复杂度为O(max(n, m))。
  * LC 133. Clone Graph
  * LC 127. Word Ladder 需二刷
    求startWord 到 endWord的最短路径长度？ 最短路径 === BFS

    隐式图，非常重要， 分层BFS
    TC: O(snm^2) 为什么是M平方？？？？-- 需要问老师
    n为dict中单词个数，s代表字符集大小(这题中是26)，m为单词长度。因为bfs所有节点最多遍历一次，每次遍历到之后，需要扫遍单词的每个字符，每个字符均可以变化为其他25个不同字母
    SC: O(nm) n为dict中单词个数，m为单词长度。用于bfs的队列最大需存下所有节点。

  * LC 126. Word Ladder II 需二刷
    
    求startWord 到 endWord的最短路径长度的所有情况？ 最短路径 === BFS， 所有情况 === DFS
    
    用BFS先构建图，得到两个hashmap： distance和map。 distance 存的是从start到当前单词的最短路径，map存的是“当前单词”->“所有能够到达这个单词的单词”的映射关系。
    
    用DFS遍历所有ladders， 选出所有最短路径。distance.get(crtWord) === distance.get(previouses[i]) + 1这个判断保证最后选出来的是最短路径
    
    学到了什么?
    先尝试了用DFS纯暴力拆解，会超时。出问题的case是wordList里单词特别的多
    
    出现的问题?
    dfs的时候忘记backtracking
    需要在开始的时候加入startWord。这道题里不能加endWord，因为endWord可能不再WordList 里，按照题目要求··这样需要返回空数组。
    DFS中path.reverse()以后，一定要再reverse回来
    


  



  



